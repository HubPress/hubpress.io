= Exploring In-line middlewares 
:hp-tags: ASP.NET Core, Middleware, Exploring

In-line middlewares are a simple way to add functionality to ASP.NET Core pipeline without going through a ceremony. In this post I'm playing with app.Run and app.Use and see how these two work.

==== Simplest middleware possible
The best way to understand how a middleware works is to remove the noise around it. so, this is the simples middleware you can build in ASP.NET Core 2.0 . 

[source,C#]
app.Run(async (context) =>
{
	await context.Response.WriteAsync("Hello World! 0");
});

By the way, that is exactly what you get when you create a new project in Visual studio,using the default template. 

As this was an exploration, I went a step further and find the actual method in source code.

[source,C#]
public static void 
Run(this IApplicationBuilder app, RequestDelegate handler)
        {
            if (app == null)
            {
                throw new ArgumentNullException(nameof(app));
            }
            if (handler == null)
            {
                throw new ArgumentNullException(nameof(handler));
            }
            app.Use(_ => handler);
        }
       
So, basically what run does is calling the app.Use method. but in this case, app.Run does not itroduce any **next** parameter, so no middleware after app.Run would run. This is a short-circuit middleware.

Now, lets take a look at app.Use method under the hood : 

[source,C#]
public static IApplicationBuilder Use(this IApplicationBuilder app, Func<HttpContext, Func<Task>, Task> middleware)
        {
            return app.Use(next =>
            {
                return context =>
                {
                    Func<Task> simpleNext = () => next(context);
                    return middleware(context, simpleNext);
                };
            });
        }

This is also an Extention method,and returning a **RequestDelegate** . so, what is a RequestDelegate !?

[source,C#]
public delegate Task RequestDelegate(HttpContext context);

A request delegate is a function that can process an HTTP request. This function returns a Task indicating the request proccessing has been completed. 

==== Conclusion
We can user app.Use to simulate app.Run method. Basically the app.Run is a simpler version of app.Use. Usually you use app.Run the the end of middleware pipeline because it is a short-circuit middleware and does not call next middleware. 

There are at least 4 different ways to show "Hello,world!" using in-line middlewares in ASP.NET Core. 

You can download the Gist here. 

[source,C#]
public class Startup
    {
        public void Configure(IApplicationBuilder app)
        {
            ////--- Default app.Run usage ----------------------------
            // app.Run(async (context) =>
            // {
            //     await context.Response.WriteAsync("Hello World! 0");
            // });            

            ////--- Default app.Use - short-cricuit--------------------
            // app.Use(async (context, next) =>
            // {
            //     await context.Response.WriteAsync("Hello World! 1");
            // });            

            ////--- simulating app.Run with a handler -----------------
            // RequestDelegate handler=async (context) =>
            // {
            //     await context.Response.WriteAsync("Hello World! 2");
            // };
            // app.Use(_ => handler);            

            ////--- simulating app.Run with an anonymous function------
            // app.Use(_ => async (context) =>
            // {
            //     await context.Response.WriteAsync("Hello World! 3");
            // });

            ////--- simulating app.Run with an anonymous function------
            app.Use( _ => async (context) =>
            {
                await context.Response.WriteAsync("Hello World! 3");
            });
        }
    }
