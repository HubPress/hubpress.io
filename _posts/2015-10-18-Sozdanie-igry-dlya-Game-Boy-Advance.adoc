= Создание игры для Game Boy Advance =

Перевод. Оригинал взят отсюда

В детстве я проводил много времени, играя на своем Game Boy (в основном, в какие-то ужасные игры). Я не писал программы ни для чего другого, кроме как для «обычных» компьютеров общего назначения, а потому задался вопросом: а насколько легко написать игру для Game Boy (Advance)?




Для тех, кто не знаком с данным девайсом:

Game Boy Advance (GBA) был популярной портативной игровой консолью, производителем которой являлась компания Nintendo (см. рис). Эта вещица была оснащена 15-битным цветным LCD-дисплеем с разрешением 240x160 (3:2), а также четырьмя кнопками на лицевой панели, двумя триггерами и крестовиной.

 Внутри Гейм Боя располагается 32-битный ARM7tdmi RISC процессор (работающий на частоте 16.78 МГц). Кроме обычных 32-битных ARM-инструкций, этот чип может также выполнять так называемые Thumb-инструкции. Thumb – это набор 16-битных инструкций, повторяющих некоторые наиболее распространенные 32-битные, который используется для экономии места.

Девайс имеет на борту 130 Кб оперативной памяти, соединенной с процессором (96 Кб которой используется для VRAM [видеопамяти], 32 Кб общего назначения и 2 Кб запаса, которые используются где угодно по мере надобности) и 256 Кб RAM, независимой от CPU. Также в системе присутствует 16 Кб встроенной памяти, которая используется для хранения BIOS. Есть еще некоторые нюансы, связанные с обратной совместимостью Game Boy Advance с Game Boy Color, но в этой статье мы затрагивать их не будем.




Помимо всей этой встроенной лабуды, в процессе своей работы Game Boy использует также различные игровые картриджи. Они обычно содержат в себе несколько ROM-банков (для хранения инструкций и read-only данных) и какое-либо перезаписываемое хранилище данных (например, SRAM, EEPROM или флеш-память). Так как картридж соединяется с устройством посредством 16-битной шины, то имеет смысл в коде игры использовать менее длинные Thumb-инструкции, нежели более громоздкие 32-битные.


Итак, все вышеописанные секции памяти, вместе с регистрами ввода/вывода (для управления графикой, звуком и т.д.) имеют примерно такую разметку в адресном пространстве:

~~~
0x00000000 - 0x00003FFF - 16 Кб ROM (исполняемая, но не читаемая)
0x02000000 - 0x02030000 - 256 Кб EWRAM (оперативная память общего назначения, независима от процессора)
0x03000000 - 0x03007FFF - 32 Кб IWRAM (оперативная память общего назначения, связана с процессором)
0x04000000 - 0x040003FF – Регистры ввода/вывода (I/O)
0x05000000 - 0x050003FF - 1 Кб палитр (RAM)
0x06000000 - 0x06017FFF - 96 Кб VRAM (видеопамять)
0x07000000 - 0x070003FF - 1 KB OAM RAM (Память атрибутов объекта – об этом позже)
0x08000000 - 0x???????? - ROM картриджа
0x0E000000 - 0x???????? - RAM картриджа
~~~
  

Особенность внутренней памяти девайса заключается в том, что у каждой секции памяти разнятся диапазоны чтения/записи (таким образом, вы не сможете записать в видеопамять отдельные байты), а также некоторые секции имеют свои копии в нескольких точках. На самом деле, присутствуют еще некоторые тонкости, но, чтобы написать простейшую игру, нам достаточно этого.

Таким образом, наш план по созданию «Hello, world» -а сводится к следующему: написать Thumb-код, который установит I/O регистры в нужное нам состояние, а после записать графические данные в видеопамять, чтобы отобразить их на экране. Давайте же попробуем! 

Настройка рабочего окружения
Чтобы начать претворять в жизнь наш план по созданию GBA рома, нам нужно узнать некоторые подробности о формате образов. Не вдаваясь в детали, каждый ром начинается со стандартного заголовка. Этот заголовок представляет собой четырехбайтовую ARM-инструкцию, указывающую адрес начала нашей программы и парочку «магических» байтов, представляющих собой лого Nintendo.

Кроме того, заголовок может содержать некоторые данные об игре (название и т.д.) и так называемое 'проверочное' число для этих данных. Мы должны убедиться в том, что заголовок сформирован правильно, дабы наш ром корректно выполнялся (особенно если мы собираемся запускать его на реальном устройстве, а не на эмуляторе).

К счастью, хороший тулчейн может справиться со всеми этими мелочами. Я использую devkitARM (часть набора devkitPro, основанного на GCC), который невероятно упрощает процесс. Собственно, достаточно один раз настроить тулчейн и мы можем создать GBA ROM в четыре шага:

Кросс-компиляция кода на C  в Thumb-инструкции, создание Thumb-файла с нашим кодом.
Линкование нашего файла в исполняемый, с применением особого файла ‘спецификаций’, для контроля процесса линкования. Обычно ‘специальные’ файлы содержат в себе скрипт для сборки (для уточнения расположения сегментов памяти, смещений и т.д.) и некоторые другие данные (например, стандартный заголовок ром-файла, коды инициализации и завершения программы и т.д.).
Очищение нашего файла от ненужной нам информации (заголовок исполняемого файла, символы и т.п.), чтобы получить почти готовый к компиляции ROM.
Запуск утилиты для исправления заголовка файла (убедитесь, что лого Nintendo корректно, и ‘проверочные’ значения проставлены верно)



С моей версией тулчейна, запущенного на машине под управлением OS X, я могу скомпилировать ROM с помощью следующих комманд (предполагая, что директория с утилитой уже находится в переменной PATH):
 
~~~
arm-none-eabi-gcc -c main.c -mthumb-interwork
-mthumb -O2 -o main.o

arm-none-eabi-gcc main.o -mthumb-interwork
-mthumb -specs=gba.specs -o main.elf

arm-none-eabi-objcopy -v -O binary main.elf
main.gba

gbafix main.gba
~~~

Есть пара дополнительных опций, которые вы, может быть, хотели бы включить в первый шаг – Я рекомендую -fno-strict-aliasing , например, так как мы имеем дело с «сырой» памятью, и не хотим, чтобы принципы работы с памятью языка C ударили нас больно в коленку. Вы также можете найти полезным написать Makefile или shell-скрипт с данными командами для компиляции рома, но эти детали я предпочту опустить в данной статье.

После того, как мы прояснили процесс компиляции, давайте же попробуем что-нибудь сделать. Для тех, кто уже устал от сухой теории, я приведу ниже код простейшей программы, а после мы его обсудим.

~~~
 int main(void) {
 // Write into the I/O registers, setting video display parameters.
 volatile unsigned char *ioram = (unsigned char *)0x04000000;
 ioram[0] = 0x03; // Set the 'video mode' to 3 (in which BG2 is a 16 bpp bitmap in VRAM)
 ioram[1] = 0x04; // Enable BG2 (BG0 = 1, BG1 = 2, BG2 = 4, ...)

 // Write pixel colours into VRAM
 volatile unsigned short *vram = (unsigned short *)0x06000000;
 vram[80*240 + 115] = 0x001F; // X = 115, Y = 80, C = 000000000011111 = R
 vram[80*240 + 120] = 0x03E0; // X = 120, Y = 80, C = 000001111100000 = G
 vram[80*240 + 125] = 0x7C00; // X = 125, Y = 80, C = 111110000000000 = B

 // Wait forever
 while(1);

 return 0;
}

~~~


Вышеприведенный код относительно прост, и должен вывести по центру экрана горизонтальный набор из трех символов: красного, зеленого и синего:

Пришло время объяснить этот код. Первым делом мы записываем некоторые параметры дисплея в уже размеченные I/O регистры – в общем-то, первые 16 бит этой размеченной памяти и есть регистр контроля дисплея (также часто называемого DISPCNT). Первые три бита этого регистра отвечают за видео-режим, а 11-ый бит показывает, включен ли фон №2 (BG@), или нет – таким образом, мы устанавливаем 3-ий видео-режим и включаем BG2.

Почему нам нужно это делать? Что ж, начнем с режима. Дело в том, что 3-ий видео-режим – это такой режим, при котором мы можем записывать битмап прямо в VRAM, и BG2 покажет эту картинку (это и есть причина, по которой мы включили BG2). Вы также можете удивиться, почему я использовал не другие видеорежимы (например, 0 или 2), а именно этот. Причина в том, что остальные режимы более сложны для объяснения (однако, позже мы все-таки используем их).

Как я упоминал ранее, LCD-дисплей Гейм Боя может отображать 15-битные цвета. Следовательно, мы можем выразить используемые цвета с помощью числовой последовательности, однако по соображениям удобства GBA использует для этого 16 бит. Собственно, так выглядит формат записи цвета:
 ?BBBBBGGGGGRRRRR . 
Это неиспользуемый бит, далее пять битов синего, пять зеленого и пять красного. 

Используя этот формат и знание того, что видео-режим 3 трактует содержание видеопамяти как картинку 240x160, наш «Hello, world» ROM просто записывает значения цвета по смещениям пикселов (предполагая, что длина unsigned short – 16 битов, vram[80*240 + 120] пропустит 80 горизонтальных строк из 240 пикселей и получит доступ к центральному пикселю выбранной строки). Заметьте, кстати, что каждый доступ к памяти в коде происходит через указатель volatile – это предотвращает предположения компилятора о том, что это бесполезное обращение к памяти.

Написание игры а-ля "Пинг-понг"
  
Раз уж мы овладели основами, давайте попробуем сделать что-то более интересное, чем отдельные пиксели. Мы все еще хотим сделать все просто, а не выстраивать проект с громоздкой инфраструктурой и вспомогательными функциями. Однако мы воспользуемся некоторыми продвинутыми возможностями рендеринга GBA. В частности, мы рассмотрим другие видеорежимы.

Хоть рисовать битмапы в режимах 3,4 и 5 очень легко, для создания многих игр это непрактичный вариант. Кроме того, что наша 240х160 картинка занимает бОльшую часть видеопамяти, так еще и помещение на экран каждого отдельного пикселя обойдется нам дорого в плане вычислительных мощностей (так что мы не можем позволить себе этот вариант, если хотим, чтобы наша игра выдавала приличное количество кадров в секунду). Таким образом, целесообразнее будет использовать режимы 0, 1 и 2.

Есть куча нюансов и хитростей работы с этими режимами, но мы пройдемся только по самым главным. Вместо того, чтобы оперировать с отдельными пикселями, первые три видеорежима GBA работают с тайлами. Тайл – это изображение 8х8. Тайлы могут существовать в 4bpp (бит на пиксель) и 8bpp, но здесь мы будем использовать первый вариант. Таким образом, тайлы будут иметь размер 32 бита (8*8*4=256 бит).

Если вы не понимаете, как мы собираемся уместить 15-битное значение цвета для каждого пикселя в 4 (или 8) бит, то не пытайтесь, потому что мы так делать не будем. Вместо того, чтобы ссылаться непосредственно на цвета, значение каждого пикселя в тайле обращается к цветам конкретной палитры. Мы можем задать значения палитр путем помещения значений цвета в соответствующую область памяти, которая может хранить 512 наборов по 16 бит (сл-но, 512 цветов). Таким образом, мы можем хранить в этой памяти одну 512-цветовую палитру, 2 256-цветовые или 32 палитры по 16 цветов.





В случае наших 4bpp 8x8 битмапов, мы будем использовать 32 палитры, в каждой из которых будет 16 цветов. Таким образом, мы можем использовать наши четыре бита на пиксель для указания индекса цвета (входящего в палитру). При использовании тайловых видеорежимов, тайлы разделены в видеопамяти на тайловые блоки или, как их еще называют, символьные блоки. Каждый блок имеет размер 16 Кб, так что мы можем уместить 512 4bpp тайлов в блок, и 6 блоков в VRAM.
Теоретически, каждый набор из 6 блоков делится на две группы – первые четыре (0-3) могут быть использованы для заднего фона, а последние два (4 и 5) – для спрайтов. Точно так же 32 палитры разделяются на 16 для фонов и 16 для спрайтов. Поскольку мы не собираемся иметь дело с бэкграундами, то нам нужны только четвертый и пятый блоки (0х6010000 и 0х6014000), а также первая цветовая палитра (0х5000200). Следующим нашим шагом станет создание спрайтов

В компьютерной графике, спрайт – это 2D-изображение, которое вписывается в более большую сцену. GBA может рендерить объекты (например, спрайты), причем этот объект сможет двигаться, не оставляя за собой след из модифицированных пикселей. При условии, что создание объектов включено (установлен бит 13 в I/O регистре контроля дисплея), объект может быть создан из отдельных наборов тайлов путем записи атрибутов в память атрибутов объекта (Object Attribute Memory – OAM). В этом случае, раз уж мы собираемся писать игру вроде «пинг-понга», то нам потребуется по меньшей мере два спрайта: шарик и «ракетка». Каждый объект имеет набор из 16-битных атрибутов:

Атрибут 0: включает, кроме всего прочего, Y-координату объекта, форму и цветовой режим (4bpp или 8bpp).
Атрибут 1: включает, кроме всего прочего, X-координату объекта и его размер
Атрибут 2: включает, кроме всего прочего, базовый тайловый индекс объекта и цветовую палитру, которую тот должен использовать (в 4bpp-режиме)

Значения для этих атрибутов можно подсмотреть, например, вот здесь, но в целом, Y-координата – это последние 8 бит атрибута 0, X-координата – последние 9 бит атрибута 1, а цветовой режим по умолчанию 4bpp (т.е 0 = 4bpp).

Биты размера и формы объекта определяют его вид и различные комбинации этих четырех битов дадут разные финальные формы объекта. Если размер объекта превышает один тайл, он будет использовать другие различные тайлы для построения своего внешнего вида. Для нас самым оптимальным решением будет использовать 1D-режим разметки, при котором объект в таком случае будет заполнять себя «базовым» тайлом, указанном в базовом тайловом индексе.

Итак, мы уже почти готовы. Мы собираемся использовать видеорежим 0, в котором BG0 – BG3 используются в «обычном» режиме (мы не можем внести в них прямые преобразования). Теперь нам нужно лишь скормить данные с крестовины Гейм Боя нашему примитивному физическому движку, поместить это все в своего рода игровой цикл, и готово!

Последний кусочек паззла – I/O регистры. Состояние входных данных может быть легко считано из регистра KEYINPUT (0х04000130) и мы можем использовать раскладку, чтобы создать маску, по которой мы легко определим, какая клавиша была нажата. А что насчет игрового цикла… Что ж, здесь нужно еще немного теории.

Типичный игровой цикл содержит в себе период прорисовки и период обновления. В нашем случае мы не можем предоставить эти циклы самим себе, иначе неизбежны искажения при движении наших объектов.

Game Boy дает нам немного времени на обновление каждый раз, как он отрисует горизонтальную строку, и даже больше (около 5 мс), когда он заканчивает отрисовку всего экрана. В этом случае, мы просто используем предоставленное девайсом время, чтобы провести наши обновления (этот период называется V-Blank).

Чтобы проверить, как много строк уже отрисовал девайс на данных момент, мы можем использовать 8-битное значение регистра VCOUNT (0x040000006) , который увеличивается в течение каждого периода V-Blank. Если значение регистра больше или равно 160, то мы попали как раз в период обновления (V-Blank). Таким образом, если мы дождемся окончательной прорисовки экрана перед тем, как начать обновление, то мы получим примитивную форму синхронизации.

Что ж, теперь мы имеем достаточно информации, чтобы написать простую игру. Я выбрал однопользовательскую игру типа пинг-понга (с крайне примитивной физикой), код которой с комментариями привожу ниже.

~~~
typedef unsigned char uint8;
typedef unsigned short uint16;
typedef unsigned int uint32;
typedef uint16 rgb15;
typedef struct object_attributes {
 uint16 attribute_zero;
 uint16 attribute_one;
 uint16 attribute_two;
 uint16 pad;
} __attribute__((aligned(4))) object_attributes;
typedef uint32 tile4bpp[8];
typedef tile4bpp tile_block[512];

#define SCREEN_WIDTH  240
#define SCREEN_HEIGHT 160

#define MEM_IO   0x04000000
#define MEM_PAL  0x05000000
#define MEM_VRAM 0x06000000
#define MEM_OAM  0x07000000

#define REG_DISPLAY        (*((volatile uint32 *)(MEM_IO)))
#define REG_DISPLAY_VCOUNT (*((volatile uint32 *)(MEM_IO + 0x0006)))
#define REG_KEY_INPUT      (*((volatile uint32 *)(MEM_IO + 0x0130)))

#define KEY_UP     0x0040
#define KEY_DOWN   0x0080
#define KEY_ANY    0x03FF

#define OBJECT_ATTRIBUTE_ZERO_Y_MASK  0xFF
#define OBJECT_ATTRIBUTE_ONE_X_MASK  0x1FF

#define oam_memory ((volatile object_attributes *)MEM_OAM)
#define tile_memory ((volatile tile_block *)MEM_VRAM)
#define object_palette_memory ((volatile rgb15 *)(MEM_PAL + 0x200))

// Form a 16-bit BGR GBA colour from three component values (hopefully, in range).
static inline rgb15 RGB15(int r, int g, int b) { return r | (g << 5) | (b << 10); }

// Set the position of an object to specified x and y coordinates (hopefully, in range).
static inline void set_object_position(volatile object_attributes *object, int x, int y) {
 object->attribute_zero = (object->attribute_zero & ~OBJECT_ATTRIBUTE_ZERO_Y_MASK) | (y & OBJECT_ATTRIBUTE_ZERO_Y_MASK);
 object->attribute_one = (object->attribute_one & ~OBJECT_ATTRIBUTE_ONE_X_MASK) | (x & OBJECT_ATTRIBUTE_ONE_X_MASK);
}

// Clamp 'value' in the range 'min' to 'max' (inclusive).
static inline int clamp(int value, int min, int max) { return (value < min ? min : (value > max ? max : value)); }

int main(void) {
 // Write the tiles for our sprites into the 4th tile block in VRAM.
 // Particularly, four tiles for an 8x32 paddle sprite, and 1 tile for an 8x8 ball sprite.
 // 0x1111 = 0001000100010001 [4bpp = colour index 1, colour index 1, colour index 1, colour index 1]
 // 0x2222 = 0002000200020002 [4bpp = colour index 2, colour index 2, colour index 2, colour index 2]
 // NOTE: We're using our own memory writing code here to avoid the byte-granular writes that
 // something like 'memset' might make (GBA VRAM doesn't support byte-granular writes).
 volatile uint16 *paddle_tile_memory = (uint16 *)tile_memory[4][1];
 for (int i = 0; i < 4 * (sizeof(tile4bpp) / 2); ++i) { paddle_tile_memory[i] = 0x1111; }
 volatile uint16 *ball_tile_memory = (uint16 *)tile_memory[4][5];
 for (int i = 0; i < (sizeof(tile4bpp) / 2); ++i) { ball_tile_memory[i] = 0x2222; }

 // Write the colour palette for our sprites into the first palette of
 // 16 colours in colour palette memory (this palette has index 0).
 object_palette_memory[1] = RGB15(0x1F, 0x1F, 0x1F); // White
 object_palette_memory[2] = RGB15(0x1F, 0x00, 0x1F); // Magenta

 // Create our sprites by writing their object attributes into OAM memory.
 volatile object_attributes *paddle_attributes = &oam_memory[0];
 paddle_attributes->attribute_zero = 0x8000; // This sprite is made up of 4bpp tiles and has the TALL shape.
 paddle_attributes->attribute_one = 0x4000; // This sprite has a size of 8x32 when the TALL shape is set.
 paddle_attributes->attribute_two = 1; // This sprite's base tile is the first tile in tile block 4, and this sprite should use colour palette 0.
 volatile object_attributes *ball_attributes = &oam_memory[1];
 ball_attributes->attribute_zero = 0; // This sprite is made up of 4bpp tiles and has the SQUARE shape.
 ball_attributes->attribute_one = 0; // This sprite has a size of 8x8 when the SQUARE shape is set.
 ball_attributes->attribute_two = 5; // This sprite's base tile is the fifth tile in tile block 4, and this sprite should use colour palette 0.

 // Initialize our variables to keep track of the state of the paddle and ball,
 // and set their initial positions (by modifying their attributes in OAM).
 const int player_width = 8, player_height = 32, ball_width = 8, ball_height = 8;
 int player_velocity = 2, ball_velocity_x = 2, ball_velocity_y = 1;
 int player_x = 5, player_y = 96;
 int ball_x = 22, ball_y = 96;
 set_object_position(paddle_attributes, player_x, player_y);
 set_object_position(ball_attributes, ball_x, ball_y);

 // Set the display parameters to enable objects, and use a 1D object->tile mapping.
 REG_DISPLAY = 0x1000 | 0x0040;

 // Our main game loop
 uint32 key_states = 0;
 while (1) {
  // Skip past the rest of any current V-Blank, then skip past the V-Draw
  while(REG_DISPLAY_VCOUNT >= 160);
  while(REG_DISPLAY_VCOUNT < 160);

  // Get current key states (REG_KEY_INPUT stores the states inverted)
  key_states = ~REG_KEY_INPUT & KEY_ANY;

  // Note that our physics update is tied to the framerate rather than a fixed timestep.
  int player_max_clamp_y = SCREEN_HEIGHT - player_height;
  if (key_states & KEY_UP) { player_y = clamp(player_y - player_velocity, 0, player_max_clamp_y); }
  if (key_states & KEY_DOWN) { player_y = clamp(player_y + player_velocity, 0, player_max_clamp_y); }
  if (key_states & KEY_UP || key_states & KEY_DOWN) { set_object_position(paddle_attributes, player_x, player_y); }

  int ball_max_clamp_x = SCREEN_WIDTH - ball_width, ball_max_clamp_y = SCREEN_HEIGHT - ball_height;
  if ((ball_x >= player_x && ball_x <= player_x + player_width) && (ball_y >= player_y && ball_y <= player_y + player_height)) {
   // This is not good physics / collision handling code.
   ball_x = player_x + player_width;
   ball_velocity_x = -ball_velocity_x;
  } else {
   if (ball_x == 0 || ball_x == ball_max_clamp_x) { ball_velocity_x = -ball_velocity_x; }
   if (ball_y == 0 || ball_y == ball_max_clamp_y) { ball_velocity_y = -ball_velocity_y; }
  }
  ball_x = clamp(ball_x + ball_velocity_x, 0, ball_max_clamp_x);
  ball_y = clamp(ball_y + ball_velocity_y, 0, ball_max_clamp_y);
  set_object_position(ball_attributes, ball_x, ball_y);
 }

 return 0;
}
~~~


Итак, мы сделали нашу первую игру для Game Boy Advance! Будет ли она работать на реальном Гейм Бое? Ф-фух, может быть. Если я не сделал нигде ошибок.
 


Заключение
Этот пост получился длиннее, чем я думал. Есть еще много деталей и нюансов разработки под GBA, описать все их в этой статье не представляется возможным. Как и любая другая платформа, Game Boy Advance имеет свои хитрости и заковырки. Я нашел для вас несколько ссылок, если вы хотите узнать побольше о разработке под эту платформу.
